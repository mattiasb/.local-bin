#!/bin/bash
# shellcheck disable=SC2317
# shellcheck disable=SC2329

set -euo pipefail

# TODO: Return the possibility to run commands on sync

################################################################################

readonly CONFIG="${XDG_CONFIG_HOME:-${HOME}/.config}/git-sync.conf"

readonly STATE_SYNC=0
readonly STATE_PULL=11
readonly STATE_PUSH=12
readonly STATE_BOTH=13

readonly ERR_GIT_NOREPO=20
readonly ERR_GIT_NOTMAIN=21
readonly ERR_GIT_STATUS=22
readonly ERR_GIT_DIRTY=23
readonly ERR_GIT_FETCH=24
readonly ERR_GIT_CONFLICT=25
readonly ERR_GIT_ABORT=26
readonly ERR_GIT_PUSH=27

readonly SYNC=✓
readonly PUSH=↑
readonly PULL=↓
readonly BOTH=⇅
readonly FAIL=×

################################################################################

function home {
    echo "${1/#\~/${HOME}}"
}

function tilde {
    echo "${1/#${HOME}/\~}"
}

function debug {
    if [ -v DEBUG ]; then
        echo "${FUNCNAME[1]:+${FUNCNAME[1]}: }${*}" >/dev/stderr
    fi
}

function error {
    echo "ERROR: ${*}" >/dev/stderr
}

function ierror {
    local line func file
    local i=0

    echo -e "INTERNAL ERROR: ${*}" >/dev/stderr
    echo -e "\nStacktrace:\n"

    while caller $((i++)); do :; done | while read -r line func file; do
        echo -e "    $(basename "${file}"):${line}\t${func}()"
    done >&2
    echo
    exit 128
}

function color {
    local color

    color="${1}"

    case "${color}" in
        b|black)   tput setaf 0 ;;
        r|red)     tput setaf 1 ;;
        g|green)   tput setaf 2 ;;
        y|yellow)  tput setaf 3 ;;
        u|blue)    tput setaf 4 ;;
        m|magenta) tput setaf 5 ;;
        c|cyan)    tput setaf 6 ;;
        w|white)   tput setaf 7 ;;
        *)         echo "ERROR: No such color ${color}!" >&2
                   return 128   ;;
    esac
    shift

    echo "${@}"

    tput sgr0
}

function task-error {
    local task failure out

    task="${1}"
    failure="${2}"
    out="${3-}"

    task-fail "${task}" "${failure}"
    echo "${out}" | pr -to 6 >&2
}

function task-fail {
    local task failure out

    task="${1}"
    failure="${2}"
    out="${3-}"

    echo -e "[ $(color r -n "${FAIL}") ] ${task} — ${failure}"
}

function task {
    local task out code
    local -a cmd

    task="${1}"
    shift
    cmd=("${@}")

    # Disable errexit so we can catch the exit code.
    #
    # If we don't do this and instead do a `|| code="${?}"`
    # then the subshell will have errexit disabled and
    # won't error out early. This happens *even* if we
    # re-enable it inside that subshell!
    #
    # We still need to re-enable it in the subshell to
    # actually get back proper errexit.
    #
    # Bash is great.
    set +e
    out="$(set -e; "${cmd[@]}")"
    code="${?}"
    set -e

    case "${code}" in
        "${STATE_SYNC}")       echo -e "[ $(color g -n "${SYNC}") ] ${task}"  ;;
        "${STATE_PULL}")       echo -e "[ $(color y -n "${PULL}") ] ${task}"  ;;
        "${STATE_PUSH}")       echo -e "[ $(color y -n "${PUSH}") ] ${task}"  ;;
        "${STATE_BOTH}")       echo -e "[ $(color y -n "${BOTH}") ] ${task}"  ;;

        "${ERR_GIT_DIRTY}")    task-fail "${task}" "Dirty"                    ;;
        "${ERR_GIT_NOREPO}")   task-fail "${task}" "Not a repo"               ;;
        "${ERR_GIT_NOTMAIN}")  task-fail "${task}" "Not on main"              ;;
        "${ERR_GIT_CONFLICT}") task-fail "${task}" "Merge conflict"           ;;

        "${ERR_GIT_STATUS}")   task-error "${task}" "Status"         "${out}" ;;
        "${ERR_GIT_FETCH}")    task-error "${task}" "Fetch"          "${out}" ;;
        "${ERR_GIT_ABORT}")    task-error "${task}" "Rebase abort"   "${out}" ;;
        "${ERR_GIT_PUSH}")     task-error "${task}" "Push"           "${out}" ;;
        *)                     task-error "${task}" "Unknown errror" "${out}" ;;
    esac
}

function config-repos {
    if [ ! -f "${CONFIG}" ]; then
        error "Loading '$(tilde "${CONFIG}")': No such file!"
        return 2
    fi

    yq '.repos[]' "${CONFIG}"
}

################################################################################

function git-is-repo {
    local repo

    repo="${1}"

    if ! command git -C "${repo}" rev-parse &>/dev/null; then
        return "${ERR_GIT_NOREPO}"
    fi
}

function git {
    local repo

    repo="${1}"
    shift

    if ! git-is-repo "${repo}"; then
        ierror "Not a repository: '${repo}'"
    fi

    command git -C "${repo}" "${@}"
}

function git-main-branch {
    local repo

    repo="${1}"

    git "${repo}" symbolic-ref refs/remotes/origin/HEAD | sed 's,.*/,,'
}

function git-branch {
    local repo

    repo="${1}"

    git "${repo}" rev-parse --abbrev-ref HEAD
}

function git-on-main {
    local repo

    repo="${1}"

    if [ "$(git-main-branch "${repo}")" != "$(git-branch "${repo}")" ]; then
        return "${ERR_GIT_NOTMAIN}"
    fi
}

function git-state {
    local repo head remote base main

    repo="${1}"

    main="$(git-main-branch "${repo}")"
    head="$(git "${repo}" rev-parse "${main}")"
    remote="$(git "${repo}" rev-parse "origin/${main}")"
    base="$(git "${repo}" merge-base "${head}" "${remote}")"

    if   [ "${head}" = "${remote}" ]; then
        echo sync
    elif [ "${base}" = "${remote}" ]; then
        echo ahead
    elif [ "${base}" = "${head}"   ]; then
        echo behind
    else
        echo diverged
    fi
}

function git-rebase {
    local repo

    repo="${1}"

    if git "${repo}" rebase 2>&1; then
        return
    fi

    if git "${repo}" rebase --abort 2>&1; then
        return "${ERR_GIT_CONFLICT}"
    fi

    return "${ERR_GIT_ABORT}"
}

function git-push {
    local repo

    repo="${1}"

    if ! git "${1}" push 2>&1; then
        return "${ERR_GIT_PUSH}"
    fi
}

function git-sync-repo {
    local repo out state

    repo="${1}"

    git-is-repo "${repo}"
    git-on-main "${repo}"

    if ! out="$(git "${repo}" status --short)"; then
        echo "${out}" >&2
        return "${ERR_GIT_STATUS}"
    elif [ -n "${out}" ]; then
        return "${ERR_GIT_DIRTY}"
    fi

    if ! git "${repo}" fetch -q 2>&1; then
        return "${ERR_GIT_FETCH}"
    fi

    state="$(git-state "${repo}")"
    case "${state}" in
        sync)     return "${STATE_SYNC}" ;;
        behind)   git-rebase "${repo}"
                  return "${STATE_PULL}" ;;
        ahead)    git-push "${repo}"
                  return "${STATE_PUSH}" ;;
        diverged) git-rebase "${repo}"
                  git-push "${repo}"
                  return "${STATE_BOTH}" ;;
        *)        error "Internal error. Unknown state '${state}'"
                  return 128
                  ;;
    esac
}

################################################################################

function usage {
    cat <<EOM
Sync git repositories.

Usage: $(basename "${0}") [-h | --help]

  -h, --help       Show this help message.
  -p, --parallel   Run in parallel (Default)
  -s, --serial     Run in serial
  -r, --repos      List all repositories instead of syncing
EOM

}

function main {
    local o name opts long
    local parallel list_repos repo
    local -a repos

    name="$(basename "${0}")"
    opts="hpsr"
    long="help,parallel,serial,repos"
    o="$(getopt -o "${opts}" -l "${long}" -n "${name}" -- "${@}")"
    eval set -- "${o}"

    parallel=8
    list_repos=0

    while true; do
        case "${1}" in
            -h | --help)
                usage
                exit
                ;;
            -p | --parallel)
                parallel=8
                shift
                ;;

            -s | --serial)
                parallel=1
                shift
                ;;

            -r | --repos)
                list_repos=1
                shift
                ;;

            -- ) shift; break ;;
            * ) break ;;
        esac
    done

    if [ "${list_repos}" = 1 ]; then
        mapfile -t repos < <(config-repos); wait $!
        for repo in "${repos[@]}"; do
            tilde "${repo}"
        done
        return
    fi

    case "${#}" in
        1) task "$(tilde "${1}")" git-sync-repo "$(home "${1}")"
           return                                                             ;;
        0) mapfile -t repos < <(config-repos); wait $!                        ;;
        *) repos=( "${@}" )                                                   ;;
    esac

    xargs -n 1 -P "${parallel}" git sync <<< "${repos[@]}"
}

main "${@}"; exit
