#!/bin/bash
# shellcheck disable=SC2329

set -euo pipefail

# TODO: Return the possibility to run commands on sync

################################################################################

readonly GIT_TIMEOUT=5s

readonly CONFIG="${XDG_CONFIG_HOME:-${HOME}/.config}/git-sync.conf"

readonly STATE_SYNC=0
readonly STATE_PULL=11
readonly STATE_PUSH=12
readonly STATE_BOTH=13

readonly ERR_GIT_NOREPO=20
readonly ERR_GIT_NOTMAIN=21
readonly ERR_GIT_STATUS=22
readonly ERR_GIT_DIRTY=23
readonly ERR_GIT_FETCH=24
readonly ERR_GIT_CONFLICT=25
readonly ERR_GIT_ABORT=26
readonly ERR_GIT_PUSH=27
readonly ERR_GIT_CLONE=28

readonly ERR_GIT_TIMEOUT=124

readonly SYNC=✓
readonly PUSH=↑
readonly PULL=↓
readonly BOTH=⇅
readonly FAIL=×

################################################################################

function home {
    echo "${1/#\~/${HOME}}"
}

function tilde {
    echo "${1/#${HOME}/\~}"
}

function debug {
    if [ -v DEBUG ]; then
        echo "${FUNCNAME[1]:+${FUNCNAME[1]}: }${*}" >/dev/stderr
    fi
}

function error {
    echo "ERROR: ${*}" >/dev/stderr
}

function ierror {
    local line func file
    local i=0

    echo -e "INTERNAL ERROR: ${*}" >/dev/stderr
    echo -e "\nStacktrace:\n"

    while caller $((i++)); do :; done | while read -r line func file; do
        echo -e "    $(basename "${file}"):${line}\t${func}()"
    done >&2
    echo
    exit 128
}

function color {
    local color

    color="${1}"

    case "${color}" in
        b|black)   tput setaf 0 ;;
        r|red)     tput setaf 1 ;;
        g|green)   tput setaf 2 ;;
        y|yellow)  tput setaf 3 ;;
        u|blue)    tput setaf 4 ;;
        m|magenta) tput setaf 5 ;;
        c|cyan)    tput setaf 6 ;;
        w|white)   tput setaf 7 ;;
        *)         echo "ERROR: No such color ${color}!" >&2
                   return 128   ;;
    esac
    shift

    echo "${@}"

    tput sgr0
}

function task-error {
    local task failure out

    task="${1}"
    failure="${2}"
    out="${3-}"

    task-fail "${task}" "${failure}"
    if [ -n "${out}"  ]; then
        echo "${out}" | pr -to 6 >&2
    fi
}

function task-fail {
    local task failure out

    task="${1}"
    failure="${2}"
    out="${3-}"

    echo -e "[ $(color r -n "${FAIL}") ] ${task} — ${failure}"
}

function task {
    local task out code
    local -a cmd

    task="${1}"
    shift
    cmd=("${@}")

    # Disable errexit so we can catch the exit code.
    #
    # If we don't do this and instead do a `|| code="${?}"`
    # then the subshell will have errexit disabled and
    # won't error out early. This happens *even* if we
    # re-enable it inside that subshell!
    #
    # We still need to re-enable it in the subshell to
    # actually get back proper errexit.
    #
    # Bash is great.
    set +e
    out="$(set -e; "${cmd[@]}" 2>&1)"
    code="${?}"
    set -e

    case "${code}" in
        "${STATE_SYNC}")       echo -e "[ $(color g -n "${SYNC}") ] ${task}"  ;;
        "${STATE_PULL}")       echo -e "[ $(color y -n "${PULL}") ] ${task}"  ;;
        "${STATE_PUSH}")       echo -e "[ $(color y -n "${PUSH}") ] ${task}"  ;;
        "${STATE_BOTH}")       echo -e "[ $(color y -n "${BOTH}") ] ${task}"  ;;

        "${ERR_GIT_DIRTY}")    task-fail "${task}" "Dirty"                    ;;
        "${ERR_GIT_NOREPO}")   task-fail "${task}" "Not a repo"               ;;
        "${ERR_GIT_NOTMAIN}")  task-fail "${task}" "Not on main"              ;;
        "${ERR_GIT_CONFLICT}") task-fail "${task}" "Merge conflict"           ;;

        "${ERR_GIT_STATUS}")   task-error "${task}" "Status"         "${out}" ;;
        "${ERR_GIT_FETCH}")    task-error "${task}" "Fetch"          "${out}" ;;
        "${ERR_GIT_ABORT}")    task-error "${task}" "Rebase abort"   "${out}" ;;
        "${ERR_GIT_PUSH}")     task-error "${task}" "Push"           "${out}" ;;
        "${ERR_GIT_CLONE}")    task-error "${task}" "Clone"          "${out}" ;;
        "${ERR_GIT_TIMEOUT}")  task-error "${task}" "Timeout"        "${out}" ;;
        *)                     task-error "${task}" "Unknown errror" "${out}" ;;
    esac
}

function config-repos {
    local repo
    local -a repos

    if [ ! -f "${CONFIG}" ]; then
        error "Loading '$(tilde "${CONFIG}")': No such file!"
        return 2
    fi

    yq '.repositories | keys[]' "${CONFIG}"
}

function config {
    local repo field q value

    repo="${1}"
    field="${2}"

    q=".repositories[\"${repo}\"].${field}"
    value="$(yq "${q}" "${CONFIG}")"

    if [ "${value}" = "null" ]; then
        ierror "The '${field}' field is unset for ${repo}. q=${q}"
    fi

    echo "${value}"
}

# NOTE: Unused
function config-remotes {
    local repo
    local -a repos

    mapfile -t repos < <(config-repos); wait $!

    for repo in "${repos[@]}"; do
        git "${repo}" remote get-url origin \
            | sed -nr 's/(https?:\/\/([^\/]+?)|[a-zA-Z0-9_]+@([^:]+)).+/\2\3/p'
    done | uniq
}

################################################################################

function git-is-repo {
    local repo

    repo="${1}"

    if ! command git -C "${repo}" rev-parse &>/dev/null; then
        return "${ERR_GIT_NOREPO}"
    fi
}

function git {
    local repo

    repo="${1}"
    shift

    if ! git-is-repo "${repo}"; then
        ierror "Not a repository: '${repo}'"
    fi

    command git -C "${repo}" "${@}"
}

function git-main-branch {
    local repo

    repo="${1}"

    git "${repo}" symbolic-ref refs/remotes/origin/HEAD | sed 's,.*/,,'
}

function git-branch {
    local repo

    repo="${1}"

    git "${repo}" rev-parse --abbrev-ref HEAD
}

function git-on-main {
    local repo

    repo="${1}"

    if [ "$(git-main-branch "${repo}")" != "$(git-branch "${repo}")" ]; then
        return "${ERR_GIT_NOTMAIN}"
    fi
}

function git-state {
    local repo head remote base main

    repo="${1}"

    main="$(git-main-branch "${repo}")"
    head="$(git "${repo}" rev-parse "${main}")"
    remote="$(git "${repo}" rev-parse "origin/${main}")"
    base="$(git "${repo}" merge-base "${head}" "${remote}")"

    if   [ "${head}" = "${remote}" ]; then
        echo sync
    elif [ "${base}" = "${remote}" ]; then
        echo ahead
    elif [ "${base}" = "${head}"   ]; then
        echo behind
    else
        echo diverged
    fi
}

function git-rebase {
    local repo

    repo="${1}"

    if git "${repo}" rebase; then
        return
    fi

    if git "${repo}" rebase --abort; then
        return "${ERR_GIT_CONFLICT}"
    fi

    return "${ERR_GIT_ABORT}"
}

function git-clone {
    local repo url out

    repo="${1}"
    url="${2}"

    echo timeout "${GIT_TIMEOUT}" git clone "${url}" "${repo}"
    if timeout "${GIT_TIMEOUT}" git clone "${url}" "${repo}"; then
        return
    else
        code="${?}"
    fi

    case "${code}" in
        0)   return                                                           ;;
        124) return "${ERR_GIT_TIMEOUT}"                                      ;;
        *)   return "${ERR_GIT_CLONE}"                                        ;;
    esac

}

function git-push {
    local repo

    repo="${1}"

    if timeout "${GIT_TIMEOUT}" git -C "${repo}" push; then
        return
    else
        code="${?}"
    fi

    case "${code}" in
        0)   return                                                           ;;
        124) return "${ERR_GIT_TIMEOUT}"                                      ;;
        *)   return "${ERR_GIT_PUSH}"                                         ;;
    esac
}

function git-fetch {
    local repo out

    repo="${1}"

    if timeout "${GIT_TIMEOUT}" git -C "${repo}" fetch -q; then
        return
    else
        code="${?}"
    fi

    case "${code}" in
        0)   return                                                           ;;
        124) return "${ERR_GIT_TIMEOUT}"                                      ;;
        *)   return "${ERR_GIT_FETCH}"                                        ;;
    esac
}

function git-sync-repo {
    local repo url name
    local out state

    repo="${1}"
    url="${2}"

    if [ ! -e "${repo}" ]; then
        git-clone "${repo}" "${url}"
        return "${STATE_PULL}"
    fi

    git-is-repo "${repo}"
    git-on-main "${repo}"

    if ! out="$(git "${repo}" status --short 2>&1)"; then
        echo "${out}" >&2
        return "${ERR_GIT_STATUS}"
    elif [ -n "${out}" ]; then
        return "${ERR_GIT_DIRTY}"
    fi

    git-fetch "${repo}"

    state="$(git-state "${repo}")"
    case "${state}" in
        sync)     return "${STATE_SYNC}" ;;
        behind)   git-rebase "${repo}"
                  return "${STATE_PULL}" ;;
        ahead)    git-push "${repo}"
                  return "${STATE_PUSH}" ;;
        diverged) git-rebase "${repo}"
                  git-push "${repo}"
                  return "${STATE_BOTH}" ;;
        *)        error "Internal error. Unknown state '${state}'"
                  return 128
                  ;;
    esac
}

################################################################################

function usage {
    cat <<EOM
Sync git repositories.

Usage: $(basename "${0}") [-h | --help]

  -h, --help       Show this help message.
  -p, --parallel   Run in parallel (Default)
  -s, --serial     Run in serial
  -r, --repos      List all repositories instead of syncing
EOM

}

function main {
    local o name opts long
    local opt_parallel opt_repos
    local repo repo_url repo_name
    local -a repos

    name="$(basename "${0}")"
    opts="hpsr"
    long="help,parallel,serial,repos"
    o="$(getopt -o "${opts}" -l "${long}" -n "${name}" -- "${@}")"
    eval set -- "${o}"

    opt_parallel=8
    opt_repos=0

    while true; do
        case "${1}" in
            -h | --help)
                usage
                exit
                ;;
            -p | --parallel)
                opt_parallel=8
                shift
                ;;

            -s | --serial)
                opt_parallel=1
                shift
                ;;

            -r | --repos)
                opt_repos=1
                shift
                ;;

            -- ) shift; break ;;
            * ) break ;;
        esac
    done

    if [ "${opt_repos}" = 1 ]; then
        mapfile -t repos < <(config-repos); wait $!
        for repo in "${repos[@]}"; do
            tilde "${repo}"
        done
        return
    fi

    case "${#}" in
        1) repo="${1}"
           repo_url="$(config  "${repo}" url)"
           repo_name="$(config "${repo}" name)"
           task "${repo_name}" git-sync-repo "$(home "${repo}")" "${repo_url}"
           return                                                             ;;
        0) mapfile -t repos < <(config-repos); wait $!                        ;;
        *) repos=( "${@}" )                                                   ;;
    esac

    xargs -n 1 -P "${opt_parallel}" git sync <<< "${repos[@]}"
}

main "${@}"; exit
